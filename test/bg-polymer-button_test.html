<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">

    <title>bg-polymer-button test</title>

    <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../web-component-tester/browser.js"></script>

    <link rel="import" href="../bg-polymer-button.html">
  </head>
  <body>

    <test-fixture id="TextPropertyTestFixture">
      <template>
        <bg-polymer-button text="button-text"></bg-polymer-button>
      </template>
    </test-fixture>

    <test-fixture id="OnClickEventTestFixture">
      <template>
        <bg-polymer-button text="my-button-text" className="btn-primary"></bg-polymer-button>
      </template>
    </test-fixture>

    <test-fixture id="ClassNamePropertyTestFixture">
      <template>
        <bg-polymer-button text="secondary-button-text" className="btn-secondary" ></bg-polymer-button>
      </template>
    </test-fixture>

    <script>
      suite('bg-polymer-button', () => {
        test('setting text property on the element works', () => {
          // Create a test fixture
          const element = fixture('TextPropertyTestFixture');
          assert.equal(element.getAttribute('text'), 'button-text');
          const elementShadowRoot = element.shadowRoot;
          const elementButton = elementShadowRoot.querySelector('button');
          assert.equal(elementButton.innerText, 'button-text');
        });
        test('setting className property on the element works', () => {
          // Create a test fixture
          const element = fixture('ClassNamePropertyTestFixture');
          expect(element.getAttribute('classname')).to.equal('btn-secondary');
          const elementShadowRoot = element.shadowRoot;
          const elementButton = elementShadowRoot.querySelector('button');
          expect(elementButton.innerText).to.equal('secondary-button-text');
          expect(elementButton.getAttribute('class')).to.equal('btn-secondary');
          // expect(elementButton.style.color).to.equal('#333f48');
        });
        // test('the on-click element on the element works', function() {
        //   const element = fixture('OnClickEventTestFixture');
        //   element.onclick = sinon.spy();
        //   // element.listen(element, 'clickHandler', 'on-click');
        //   element.click();
        //   const elementShadowRoot = element.shadowRoot;
        //   const elementButton = elementShadowRoot.querySelector('button');
        //   expect(elementButton._handleClick).to.have.been.called;
        // });
      });
    </script>

  </body>
</html>
